<document index="0">
<source>tach/readme.md</source>
<document_content>
# Tach

[![downloads](https://static.pepy.tech/badge/tach/month)](https://pepy.tech/project/tach)
[![version](https://img.shields.io/pypi/v/tach.svg)](https://pypi.Python.org/pypi/tach)
[![license](https://img.shields.io/pypi/l/tach.svg)](https://pypi.Python.org/pypi/tach)
[![python](https://img.shields.io/pypi/pyversions/tach.svg)](https://pypi.Python.org/pypi/tach)
[![ci](https://github.com/gauge-sh/tach/actions/workflows/ci.yml/badge.svg)](https://github.com/gauge-sh/tach/actions/workflows/ci.yml)
[![pyright](https://microsoft.github.io/pyright/img/pyright_badge.svg)](https://microsoft.github.io/pyright/)
[![ruff](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/astral-sh/ruff/main/assets/badge/v2.json)](https://github.com/astral-sh/ruff)

Tach is a Python tool to enforce dependencies and interfaces, written in Rust.

Tach is inspired by the [modular monolith](https://www.milanjovanovic.tech/blog/what-is-a-modular-monolith) architecture.

[Docs](https://docs.gauge.sh)

[Discord](https://discord.gg/Kz2TnszerR)

<div align="center">
    <img src="docs/assets/light_logo.png" alt="gauge-logo" width="30%"  style="border-radius: 50%; padding-bottom: 20px"/>
</div>

https://github.com/user-attachments/assets/11eec4a1-f80a-4f13-9ff3-91a9760133b6



Tach can enforce:

- 📋 Imports only come from [declared dependencies](https://docs.gauge.sh/usage/configuration#modules)
- 🤝 Cross-module calls use the [public interface](https://docs.gauge.sh/usage/configuration#interfaces)
- ⛓️‍💥 [No cycles](https://docs.gauge.sh/usage/configuration) in the dependency graph


Tach is:

- 🌎 Open source
- 🐍 Installable via pip
- 🔧 Able to be adopted incrementally
- ⚡ Implemented with no runtime impact
- ♾️ Interoperable with your existing systems

## Getting Started

### Installation

```bash
pip install tach
```

### Setup

Tach will guide you through initial project setup.

Run:
```bash
 tach init
```

After an introductory message, you will see a file tree interface allowing you to interactively configure your project.

Use the arrow keys to navigate, and mark each module boundary with 'Enter'. You can mark all of your top-level Python packages, or just a few that you want to track.

FAQ: [What is a module?](https://docs.gauge.sh/usage/faq#what-is-a-module%3F)

If your Python code lives below your project root, or if you are working in a monorepo with multiple Python packages, mark your Python [source roots](https://docs.gauge.sh/usage/configuration#source-roots) using the 's' key.

### Enforcement

Tach comes with a cli command to enforce the boundaries that you just set up! From the root of your Python project, run:

```bash
tach check
```

You will see:

```bash
✅ All modules validated!
```

You can validate that Tach is working by:

1. Removing an item from the `depends_on` key in `tach.toml`, or marking it as [deprecated](https://docs.gauge.sh/usage/deprecate)
2. By adding an import between modules that didn't previously import from each other.

Give both a try and run `tach check` again. This will generate an error:

```bash
❌ tach/check.py[L8]: Cannot use 'tach.filesystem'. Module 'tach' cannot depend on 'tach.filesystem'.
```

Each error indicates an import which violates your dependencies. If your terminal supports hyperlinks, click on the file path to go directly to the error.

When an error is detected, `tach check` will exit with a non-zero code. It can be easily integrated with CI/CD, [Pre-commit hooks](https://docs.gauge.sh/usage/commands#tach-install), and [VS Code](https://marketplace.visualstudio.com/items?itemName=Gauge.tach), and more!

### Extras

Visualize your dependency graph.

```bash
tach show [--web]
```

Tach will generate a graph of your dependencies. Here's what this looks like for Tach:

![tach show](docs/assets/tach_show.png)

Note that this graph is generated remotely with the contents of your `tach.toml` when running `tach show --web`.

If you would like to use the [GraphViz DOT format](https://graphviz.org/about/) locally, simply running `tach show` will generate `tach_module_graph.dot` in your working directory.

You can view the dependencies and usages for a given path:

```bash
tach report my_package/
# OR
tach report my_module.py
```

e.g.:

```bash
> tach report python/tach/filesystem
[Dependencies of 'python/tach/filesystem']
python/tach/filesystem/install.py[L6]: Import 'tach.hooks.build_pre_commit_hook_content'
python/tach/filesystem/project.py[L5]: Import 'tach.constants.CONFIG_FILE_NAME'
...
-------------------------------
[Usages of 'python/tach/filesystem']
python/tach/cache/access.py[L8]: Import 'tach.filesystem.find_project_config_root'
python/tach/cache/setup.py[L7]: Import 'tach.filesystem.find_project_config_root'
...
```

Tach also supports:

- [Public interfaces for modules](https://docs.gauge.sh/usage/interfaces/)
- [Deprecating individual dependencies](https://docs.gauge.sh/usage/deprecate)
- [Layered architecture](https://docs.gauge.sh/usage/layers)
- [Incremental adoption](https://docs.gauge.sh/usage/unchecked-modules)
- [Manual file configuration](https://docs.gauge.sh/usage/configuration)
- [Monorepos and namespace packages](https://docs.gauge.sh/usage/configuration#source-roots)
- [Domain ownership](https://docs.gauge.sh/usage/configuration#tach-domain-toml)
- [Inline 'ignore' comments](https://docs.gauge.sh/usage/tach-ignore)1
- [Pre-commit hooks](https://docs.gauge.sh/usage/commands#tach-install)

More info in the [docs](https://docs.gauge.sh/). Tach logs anonymized usage statistics which can be [opted out](https://docs.gauge.sh/usage/faq/) of.
If you have any feedback, we'd love to talk!

If you have any questions or run into any issues, let us know by either reaching out on [Discord](https://discord.gg/Kz2TnszerR) or submitting a [Github Issue](https://github.com/gauge-sh/tach/issues)!

---

### Contributors

<a href="https://github.com/gauge-sh/tach/graphs/contributors">
  <img src="https://contrib.rocks/image?repo=gauge-sh/tach" />
</a>

</document_content>
</document>
<document index="1">
<source>docs/README.md</source>
<document_content>
# Mintlify Starter Kit

Click on `Use this template` to copy the Mintlify starter kit. The starter kit contains examples including

- Guide pages
- Navigation
- Customizations
- API Reference pages
- Use of popular components

### Development

Install the [Mintlify CLI](https://www.npmjs.com/package/mintlify) to preview the documentation changes locally. To install, use the following command

```
npm i -g mintlify
```

Run the following command at the root of your documentation (where mint.json is)

```
mintlify dev
```

### Publishing Changes

Install our Github App to auto propagate changes from your repo to your deployment. Changes will be deployed to production automatically after pushing to the default branch. Find the link to install on your dashboard. 

#### Troubleshooting

- Mintlify dev isn't running - Run `mintlify install` it'll re-install dependencies.
- Page loads as a 404 - Make sure you are running in a folder with `mint.json`

</document_content>
</document>
<document index="2">
<source>docs/contributing/setting-up-project.mdx</source>
<document_content>
---
title: Setup Guide
---

## 1. Automated dependency installation
Installing all the dependencies
```bash
 make deps
```

### Troubleshooting

#### Issue: `python: command not found`

On some systems, the `make deps` command may fail with an error stating that the `python` command is not found. This happens because some systems only provide `python3` and do not include a `python` symlink.

#### macOS Fix:
If you're on macOS, create a symbolic link for `python` pointing to `python3`:

```bash
sudo ln -s $(which python3) /usr/local/bin/python
```

#### Linux Fix:

```bash
sudo ln -s $(which python3) /usr/bin/python
```

#### Windows Fix:
On Windows, ensure Python is installed and added to your `PATH`. You can check by running:

```powershell
python --version
```

If `python` is not recognized, use the `python3` command instead, or create an alias in PowerShell:

```powershell
Set-Alias -Name python -Value python3
```

After applying the appropriate fix, retry:

```bash
make deps
```

## 2. Build

To build and rebuild after changes to Rust files.

<Note>
Make sure you have the Rust compiler installed. This package requires Rust and Cargo to compile extensions.
</Note>

### Install the crate as module in the current virtualenv

```bash
make install
```

## 3. Test

Tach internally uses `pytest` module for testing all the files within `python/tests/`
```bash
make test
```

## 4. Setting up the docs
Tach internally uses `mintlify` platform to create and maintain public facing documentation

Note: contributors would need to install [Node](https://nodejs.org/en/download/prebuilt-installer) and [npm](https://www.npmjs.com/)
```bash 
make docs
```

## 5. Things to check before committing
Check and sync your dependencies in the root folder
```bash
tach check
tach sync
```
Type checking
```bash 
make type-check
```
Run linting checks for Rust and Python code
```bash
make lint
```
Format Rust and Python code
```bash
make fmt
```

That's it! You are now ready to push your new dev branch to your forked repo and then raise a PR with appropriate description

Find Beginner Friendly issues here: 
- [Good First Issues (For beginners)](https://github.com/gauge-sh/tach/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22)
- [Documentation Issues](https://github.com/gauge-sh/tach/issues?q=is%3Aopen+is%3Aissue+label%3Adocumentation)
- [Issues](https://github.com/gauge-sh/tach/issues)
- [Documentation](https://github.com/gauge-sh/tach/tree/main/docs)

For any questions, just drop a message in [Discord](https://discord.com/invite/a58vW8dnmw)
</document_content>
</document>
<document index="3">
<source>docs/getting-started/getting-started.mdx</source>
<document_content>
---
title: Getting Started
---

### Installation

```bash
pip install tach
```

### Setup

Tach will guide you through initial project setup.

Run:
```bash
 tach init
```

After an introductory message, you will see a file tree interface allowing you to interactively configure your project.

Use the arrow keys to navigate, and mark each module boundary with 'Enter'. You can mark all of your top-level Python packages, or just a few that you want to track.

If your Python code lives below your project root, or if you are working in a monorepo with multiple Python packages, mark your Python [source roots](https://docs.gauge.sh/usage/configuration#source-roots) using the 's' key.

### Enforcement

Tach comes with a cli command to enforce the boundaries that you just set up! From the root of your Python project, run:

```bash
tach check
```

You will see:

```bash
✅ All modules validated!
```

You can validate that Tach is working by:

1. Removing an item from the `depends_on` key in `tach.toml`, or marking it as [deprecated](https://docs.gauge.sh/usage/deprecate)
2. By adding an import between modules that didn't previously import from each other.

Give both a try and run `tach check` again. This will generate an error:

```bash
❌ tach/check.py[L8]: Cannot use 'tach.filesystem'. Module 'tach' cannot depend on 'tach.filesystem'.
```

Each error indicates an import which violates your dependencies. If your terminal supports hyperlinks, click on the file path to go directly to the error.

When an error is detected, `tach check` will exit with a non-zero code. It can be easily integrated with CI/CD, [Pre-commit hooks](https://docs.gauge.sh/usage/commands#tach-install), and [VS Code](https://marketplace.visualstudio.com/items?itemName=Gauge.tach), and more!

### Extras

Visualize your dependency graph.

```bash
tach show [--web]
```

Tach will generate a graph of your dependencies. Here's what this looks like for Tach:

![tach show](../assets/tach_show.png)

Note that this graph is generated remotely with the contents of your `tach.toml` when running `tach show --web`.

If you would like to use the [GraphViz DOT format](https://graphviz.org/about/) locally, simply running `tach show` will generate `tach_module_graph.dot` in your working directory.

You can view the dependencies and usages for a given path:

```bash
tach report my_package/
# OR
tach report my_module.py
```

e.g.:

```bash
> tach report python/tach/filesystem
[Dependencies of 'python/tach/filesystem']
python/tach/filesystem/install.py[L6]: Import 'tach.hooks.build_pre_commit_hook_content'
python/tach/filesystem/project.py[L5]: Import 'tach.constants.CONFIG_FILE_NAME'
...
-------------------------------
[Usages of 'python/tach/filesystem']
python/tach/cache/access.py[L8]: Import 'tach.filesystem.find_project_config_root'
python/tach/cache/setup.py[L7]: Import 'tach.filesystem.find_project_config_root'
...
```

Tach also supports:

- [Public interfaces for modules](../usage/interfaces)
- [Deprecating individual dependencies](../usage/deprecate)
- [Manual file configuration](../usage/configuration)
- [Monorepos and namespace packages](../usage/configuration#source-roots)
- [Inline exceptions](../usage/tach-ignore)
- [Pre-commit hooks](../usage/command#tach-install)

</document_content>
</document>
<document index="4">
<source>docs/getting-started/introduction.mdx</source>
<document_content>
---
title: Overview
---

## What is Tach?

Tach allows you to control dependencies between your Python modules.
Modules can also define an explicit public interface to prevent deep coupling.

This creates a modular architecture, which makes development easier.

If a module tries to import from another module that is not listed as a dependency, Tach will report an error.

When a module has a [public interface](../usage/interfaces), any import which does not go through the public interface will cause Tach to report an error.

Dependencies can be additionally marked as ['deprecated'](../usage/deprecate). Tach will not report an error but will surface usages of the deprecated dependency.

Tach is a CLI tool, and is ideal for pre-commit hooks and CI checks.

Tach is:

- 🌎 Open source
- 🐍 Installable via pip
- 🔧 Able to be adopted incrementally
- ⚡ Implemented with no runtime impact
- ♾️ Interoperable with your existing systems (cli, hooks, ci, etc.)

## Commands

- [`tach mod`](../usage/commands#tach-mod) - Interactively define module boundaries.
- [`tach check`](../usage/commands#tach-check) - Check that boundaries and interfaces are respected.
- [`tach sync`](../usage/commands#tach-sync) - Sync constraints with the actual dependencies in your project.
- [`tach show`](../usage/commands#tach-show) - Visualize your project's dependency graph.
- [`tach check-external`](../usage/commands#tach-check-external) - Check 3rd party imports match dependencies in your packages.
- [`tach report`](../usage/commands#tach-report) - Generate a dependency report for a file or module.
- [`tach test`](../usage/commands#tach-test) - Run only the tests impacted by your changes
- [`tach install`](../usage/commands#tach-install) - Install Tach into your development workflow (e.g. pre-commit)

</document_content>
</document>
<document index="5">
<source>docs/getting-started/why-tach.mdx</source>
<document_content>
---
title: Why Tach
---

## The Problem

Python allows you to import and use anything, anywhere. Over time, this results in modules that were intended to be separate getting tightly coupled together, and domain boundaries breaking down.

We experienced this first-hand at a unicorn startup, where the entire engineering team paused development for over a year in an attempt to split up tightly coupled packages into independent microservices. This ultimately failed, and resulted in the CTO getting fired.

This problem occurs because:

- It's much easier to add to an existing package rather than create a new one
- Junior devs have a limited understanding of the existing architecture
- External pressure leading to shortcuts and overlooking best practices

Attempts we've seen to fix this problem always came up short. A patchwork of solutions would attempt to solve this from different angles, such as developer education, CODEOWNERs, standard guides, refactors, and more. However, none of these addressed the root cause.

## The Solution

With Tach, you can:

1. Declare your modules ([`tach mod`](../usage/commands#tach-mod))
2. Automatically declare dependencies ([`tach sync`](../usage/commands#tach-sync))
3. Enforce those dependencies ([`tach check`](../usage/commands#tach-check))
4. Visualize those dependencies ([`tach show`](../usage/commands#tach-show) and [`tach report`](../usage/commands#tach-report))

You can also enforce a [public interface](../usage/interfaces) for each module, and [deprecate dependencies](../usage/deprecate) over time. This means that only members that are listed in `__all__` can be imported by other modules.

</document_content>
</document>
<document index="6">
<source>docs/usage/caching.mdx</source>
<document_content>
---
title: Caching
---

Tach makes use of a 'computation cache' to speed up certain tasks, such as [testing](commands#tach-test).

When Tach finds cached results for a given task, the terminal output is enclosed in:

```
============ Cached results found!  ============
...
============ END Cached results  ============
```

Caching is done at the command level. This means a single invocation of `tach test` can only ever result in a single cache hit or miss. Individual tests are not cached separately.

## Cache content

The computation cache contains the output from `stdout` and `stderr` from a previous task invocation.

This is done to enable 'replaying' cached tasks so that their output can be reused seamlessly.

## Determining cache hits

Tach uses several pieces of information to determine cache hits:

- Python interpreter version (`major.minor.micro`)
- All Python file contents beneath your [source roots](configuration#source-roots)
- Declared versions of 3rd party dependencies in project requirements (`requirements.txt` or `pyproject.toml`)
- File contents of explicitly configured [file dependencies](configuration#cache)
- Explicitly configured [environment variable values](configuration#cache)

When all of these match a previous cache entry, the cached results are printed directly to the terminal.

## Cache storage

The computation cache exists within the `.tach` directory in your project root. The directory is managed by Tach, and your cached results are stored on-disk on each machine where tasks are run.

We are currently working on a _remote cache_ backend, which will allow multiple developers and CI environments to share a centralized cache to maximize the hit rate. If you are interested in this functionality, reach out on [Discord](https://discord.gg/a58vW8dnmw), through a [GitHub issue](https://github.com/gauge-sh/tach/issues), or via email: [evan@gauge.sh](mailto://evan@gauge.sh); [caelean@gauge.sh](mailto://caelean@gauge.sh)!

## Disabling the cache

The computation cache is enabled by default for commands such as [tach test](usage.md#tach-test). It can be disabled using `--disable-cache`. This will prevent all access to the cache and run the underlying command unconditionally.

</document_content>
</document>
<document index="7">
<source>docs/usage/commands.mdx</source>
<document_content>
---
title: Commands
---

## tach init

Tach provides a guided setup process in `tach init`. This command will provide guidance and perform validation,
while walking through `tach mod`, `tach sync` and `tach show`.

New users should start with this command.

```bash
usage: tach init [-h] [--force]

Initialize a new project

options:
  -h, --help  show this help message and exit
  --force     Force re-initialization if project is already configured.
```

## tach mod

Tach provides an interactive editor for configuring your module boundaries - `tach mod`.

```bash
usage: tach mod [-h] [-d [DEPTH]] [-e file_or_path,...]

Configure module boundaries interactively

options:
  -h, --help            show this help message and exit
  -d [DEPTH], --depth [DEPTH]
                        The number of child directories to expand from the root
  -e file_or_path,..., --exclude file_or_path,...
                        Comma separated path list to exclude. tests/, ci/, etc.
```

Running `tach mod` will open an editor in your terminal where you can mark your module boundaries.

You can navigate with the arrow keys, mark individual modules with `Enter`, and mark all siblings
as modules with `Ctrl + a`.

You can also mark your Python [source roots](configuration#source-roots) by pressing `s`.
This allows Tach to understand module paths and correctly identify first-party imports.

You can mark modules as [utilities](configuration#modules) by pressing `u`. This is appropriate for modules like `utils/`, which can be freely used by the rest of the code.

To save your modules, use `Ctrl + s`. Otherwise, to exit without saving, use `Ctrl + c`.

Any time you make changes with `tach mod`, run [`tach sync`](commands#tach-sync)
to automatically configure dependency rules.

## tach sync

Tach can automatically sync your project configuration (`tach.toml`) with your project's actual dependencies.

```bash
usage: tach sync [-h] [--add] [-e file_or_path,...]

Sync constraints with actual dependencies in your project.

options:
  -h, --help            show this help message and exit
  --add                 add all existing constraints and re-sync dependencies.
  -e file_or_path,..., --exclude file_or_path,...
                        Comma separated path list to exclude. tests/, ci/, etc.
```

When this command runs, Tach will analyze the imports in your Python project.

Any undeclared dependencies will be automatically resolved by
adding the corresponding dependencies to your `tach.toml` file.

With `--add`,
any missing dependencies in your `tach.toml` will be added, but does not remove unused dependencies.

When run without the `--add` flag, `tach sync` will remove modules from the `tach.yml` file that do not exist in the project's source roots.

## tach check

Tach will flag any unwanted imports between modules. We recommend you run `tach check` like a linter or test runner, e.g. in pre-commit hooks, on-save hooks, and in CI pipelines.

```bash
usage: tach check [-h] [--exact] [--dependencies] [--interfaces] [-e file_or_path,...]

Check existing boundaries against your dependencies and module interfaces

options:
  -h, --help            show this help message and exit
  --exact               When checking dependencies, raise errors if any dependencies are unused.
  --dependencies        Check dependency constraints between modules. When present, all checks must be explicitly enabled.
  --interfaces          Check interface implementations. When present, all checks must be explicitly enabled.
  -e file_or_path,..., --exclude file_or_path,...
                        Comma separated path list to exclude. tests/, ci/, etc.
```

Using the `--dependencies` or `--interfaces` flag will limit the checks performed to the respective category.
By default, all checks will be performed.

### Dependency Errors
An error will indicate:

- the file path in which the error was detected
- the module associated with that file
- the module associated with the attempted import

If `--exact` is provided, additional errors will be raised if a dependency exists in `tach.toml` that does not exist in the code.

Example:

```bash
> tach check
❌ tach/check.py[L8]: Cannot import 'tach.filesystem'. Module 'tach' cannot depend on 'tach.filesystem'.
```

NOTE: If your terminal supports hyperlinks, you can click on the failing file path to go directly to the error.


### Interface Errors
An error will indicate:

- the file path in which the error was detected
- the module associated with that file
- the module associated with the attempted import
- the non-public member associated with the attempted import

Example:

```bash
❌  tach/mod.py[L13]: Module 'tach.interactive' has a defined public interface. Only imports from the public interface of this module are allowed. The import 'tach.interactive.get_selected_modules_interactive' (in module 'tach.mod') is not public.
```

NOTE: If your terminal supports hyperlinks, you can click on the failing file path to go directly to the error.

## tach check-external

Tach can validate that the external imports in your Python packages match your declared package dependencies in `pyproject.toml` or `requirements.txt`.

```bash
usage: tach check-external [-h] [-e file_or_path,...]

Perform checks related to third-party dependencies

options:
  -h, --help  show this help message and exit
  -e file_or_path,..., --exclude file_or_path,...
                        Comma separated path list to exclude. tests/, ci/, etc.
```

For all Python files in each [source root](../configuration#source-roots), Tach will determine which package it belongs to,
and compare its dependencies to those declared in `pyproject.toml` or `requirements.txt`.
Tach will report an error for any external import which is not satisfied by the declared dependencies.

This also means that, for monorepos which contain multiple Python packages, Tach will detect when an import comes from a source root in another package,
and verify that this dependency is declared. Make sure to configure [`source_roots`](../configuration#source-roots) for every package (globs are coming soon!).

This is typically useful if you are developing more than one Python package from a single virtual environment.
Although your local environment may contain the dependencies for all your packages, when an end-user installs each package they will only install the dependencies listed in the `pyproject.toml`.

This means that, although tests may pass in your shared environment, an invalid import can still cause errors at runtime for your users.

In case you would like to explicitly allow a certain external module, this can be configured in your [`tach.toml`](configuration#external-checks)

<Note>
  It is recommended to run Tach within a virtual environment containing all of
  your dependencies across all packages. This is because Tach uses the
  distribution metadata to map module names like 'git' to their distributions
  ('GitPython').
</Note>

## tach report

Tach can generate a report showing all the dependencies and usages of a given module.

```bash
usage: tach report [-h] [--dependencies] [--usages] [--external] [-d module_path,...] [-u module_path,...] [--raw] [-e file_or_path,...] path

Create a report of dependencies and usages.

positional arguments:
  path                  The path or directory path used to generate the report.

options:
  -h, --help            show this help message and exit
  --dependencies        Generate dependency report. When present, all reports must be explicitly enabled.
  --usages              Generate usage report. When present, all reports must be explicitly enabled.
  --external            Generate external dependency report. When present, all reports must be explicitly enabled.
  -d module_path,..., --dependency-modules module_path,...
                        Comma separated module list of dependencies to include [includes everything by default]
  -u module_path,..., --usage-modules module_path,...
                        Comma separated module list of usages to include [includes everything by default]
  --raw                 Group lines by module and print each without any formatting.
  -e file_or_path,..., --exclude file_or_path,...
                        Comma separated path list to exclude. tests/, ci/, etc.
```

By default, this will generate a textual report showing the file and line number of each module dependency, module usage, and external dependency. Each section corresponds to a command line flag.

The given `path` can be a directory or a file path. The [module](../configuration#modules) which contains the given path will be used to determine which imports to include in the report.
Generally, if an import points to a file which is contained by a different module, it will be included.

The `--dependencies` flag includes module dependencies, meaning any import which targets a different module within your project. For example, if `core.api` and `core.services` are marked as modules,
then an import of `core.api.member` from within `core.services` would be included in a report for `core/services`.

The `--usages` flag includes module usages, meaning any import which comes from a different module within your project. For example, if `core.api` and `core.services` are marked as modules,
then an import of `core.services.member` from within `core.api` would be included in a report for `core/services`.

The `--external` flag includes external (3rd party) dependencies, meaning any import which targets a module outside of your project. For example, importing `pydantic` or `tomli` would be included in this report.

<Note>
  It is recommended to run Tach within a virtual environment containing all of
  your dependencies across all packages. This is because Tach uses the
  distribution metadata to map 3rd party module names like 'git' to their distributions
  ('GitPython').
</Note>

Supplying the `--raw` flag will group the results by module name and eliminate formatting, making the output more easily machine-readable.

## tach show

Tach will generate a visual representation of your dependency graph!

```bash
usage: tach show [-h] [--web] [--mermaid] [-o [OUT]] [included_paths ...]

Visualize the dependency graph of your project.

positional arguments:
  included_paths        Paths to include in the module graph. If not provided, the entire project is
                        included.

options:
  -h, --help            show this help message and exit
  --web                 Open your dependency graph in a remote web viewer.
  --mermaid             Generate a mermaid.js graph instead of a DOT file.
  -o [OUT], --out [OUT]
                        Specify an output path for a locally generated module graph file.
```

These are the results of `tach show --web` on the Tach codebase itself:
![tach show](assets/tach_show.png)

## tach test

Tach also functions as an intelligent test runner.

```
usage: tach test [-h] [--base [BASE]] [--head [HEAD]] [--disable-cache] ...
Run tests on modules impacted by the current changes.
positional arguments:
  pytest_args      Arguments forwarded to pytest. Use '--' to separate
                   these arguments. Ex: 'tach test -- -v'
options:
  -h, --help       show this help message and exit
  --base [BASE]    The base commit to use when determining which modules
                   are impacted by changes. [default: 'main']
  --head [HEAD]    The head commit to use when determining which modules
                   are impacted by changes. [default: current filesystem]
  --disable-cache  Do not check cache for results, and
                   do not push results to cache.
```

Using `pytest`, running `tach test` will perform [impact analysis](https://martinfowler.com/articles/rise-test-impact-analysis.html) on the changes between your current filesystem and your `main` branch to determine which test files need to be run.
This can dramatically speed up your test suite in CI, particularly when you make a small change to a large codebase.
This command also takes advantage of Tach's [computation cache](caching).

## tach install

Tach can be installed into your development workflow automatically as a pre-commit hook.

### With pre-commit framework

If you use the [pre-commit framework](https://github.com/pre-commit/pre-commit), you can add the following to your `.pre-commit-hooks.yaml`:

```yaml
repos:
  - repo: https://github.com/gauge-sh/tach-pre-commit
    rev: v0.28.1 # change this to the latest tag!
    hooks:
      - id: tach
```

Note that you should specify the version you are using in the `rev` key.

### Standard install

If you don't already have pre-commit hooks set up, you can run:

```bash
tach install pre-commit
```

The command above will install `tach check` as a pre-commit hook, directly into `.git/hooks/pre-commit`.

If that file already exists, you will need to manually add `tach check` to your existing `.git/hooks/pre-commit` file.

</document_content>
</document>
<document index="8">
<source>docs/usage/configuration.mdx</source>
<document_content>
---
title: Configuration
---

Aside from running `tach mod` and `tach sync`, you can configure Tach by creating or modifying the configuration file as described below.

## `tach.toml`

This is the project-level configuration file which should be in the root of your project.

`modules` defines the modules in your project - [see details](#modules).

`interfaces` defines the interfaces of modules in your project (optional) - [see details](#interfaces).

`layers` defines the layers of modules in your project (optional) - [see details](#layers).

`exclude` accepts a list of directory patterns to exclude from checking. These should be glob paths which match from the beginning of a given file path. For example: `project/*.tests` would match any path beginning with `project/` and ending with `.tests`.

<Note>
  Tach uses forward slashes to match path separators, even on Windows.
</Note>

`ignore_type_checking_imports` (default: **true**) is a flag which silences `tach check` failures caused by imports under a `TYPE_CHECKING` conditional block.

`exact` (default: **false**) is a flag which causes `tach check` to fail if any declared dependencies are found to be unused.

`forbid_circular_dependencies` (default: **false**) is a flag which causes `tach check` to fail if any circular dependencies are detected.

`respect_gitignore` (default: **true**) is a flag which causes Tach to exclude files and directories matched by `.gitignore`.

`root_module` takes a string enum value, and determines how Tach treats code which lives within the project but is not covered by an explicit module. This is described in detail [below](#the_root_module)

`rules` allows precise configuration of the severity of certain types of issues. See [below](#rules) for more details.

**[DEPRECATED]** `use_regex_matching` (default: **false**) is a flag which controls how exclude patterns are interpreted.
By default, exclude patterns are interpreted as globs. But when this flag is `true`, exclude patterns are interpreted as regex.

<Warning>The `use_regex_matching` configuration option will be removed in a future version of Tach. If you have already customized your `exclude` list, it is likely that you will need to update your patterns to globs.</Warning>

```toml
exclude = [
    "**/*__pycache__",
    "build/",
    "dist/",
    "docs/",
    "python/tests/",
    "tach.egg-info/",
    "venv/",
]
source_roots = ["python"]
exact = true
ignore_type_checking_imports = true
forbid_circular_dependencies = true

layers = [
  "ui",
  "commands",
  "core"
]

[[modules]]
path = "tach"
depends_on = []

[[modules]]
path = "tach.__main__"
layer = "ui"

[[modules]]
path = "tach.errors"
depends_on = []
utility = true

[[modules]]
path = "tach.parsing"
depends_on = ["tach", "tach.filesystem"]
layer = "core"
visibility = ["tach.check"]

[[modules]]
path = "tach.check"
depends_on = [
    "tach.extension",
    "tach.filesystem",
    "tach.parsing",
]
layer = "commands"

[[interfaces]]
expose = ["types.*"]

[[interfaces]]
expose = [
    "parse_project_config",
    "dump_project_config_to_toml",
]
from = [
    "tach.parsing",
]

...

[cache]
file_dependencies = ["python/tests/**", "src/*.rs"]

[external]
exclude = ["pytest"]

[rules]
unused_ignore_directives = "warn"
```

## Modules

Each module listed under the `modules` key above can accept the following attributes:

- `path` the Python import path to the module (e.g. `a.b` for `<root>/a/b.py`)
<Note>Glob patterns are allowed. The pattern `"libs.**"` would define the default configuration for any module under the `libs` namespace.<br/><br/>This can be overridden for specific modules by defining them later in the file using a concrete pattern like `"libs.module"`.</Note>
<Note>A module can also define `paths` as a shorthand for multiple module definitions. This allows specifying allowed dependencies and other attributes as a group.<br></br><br></br>Example: `paths = ["a.b", "a.c"]`</Note>
- `depends_on` a list of module paths which this module can import from
<Note>Glob patterns are allowed. The pattern `"libs.**"` would allow dependencies on any module under the `libs` namespace.</Note>
<Note>Omitting the `depends_on` field means the module will be allowed to import from any other module. However, it will still be subject to those modules' [public interfaces](#interfaces).</Note>
- `cannot_depend_on` a list of module paths which this module cannot import from
<Note>This takes precedence over `depends_on`. In other words, if `cannot_depend_on = ["module"]`, then `depends_on = ["module"]` will have no effect.</Note>
- `layer` (optional) the [**layer**](#layers) which holds this module
- `visibility` (optional) a list of other modules which can import from this module
- `utility` (default: `false`) marks this module as a **Utility**, meaning all other modules may import from it without declaring an explicit dependency
- `unchecked` (default: `false`) marks this module as [**unchecked**](../usage/unchecked-modules), meaning Tach will not check its imports

<Note>
  Tach also supports [deprecating individual dependencies](../usage/deprecate).
</Note>

## Interfaces

Public interfaces are defined separately from modules, and define the imports that are allowed from that module.

For example, if a module should expose everything from a nested 'services' folder, the config would look like:

```toml
[[interfaces]]
expose = ["services.*"]
from = ["my_module"]
```

More specifically:

- `expose`: a list of regex patterns which define the public interface
- `from` (optional): a list of regex patterns which define the modules which adopt this interface
- `visibility` (optional): a list of modules which can use this interface
- `exclusive` (default: `false`): when paired with `visibility`, requires that matching modules use _only_ this interface

[More details here.](../usage/interfaces)

<Note>
If an interface entry does not specify `from`, all modules will adopt the interface.
</Note>

<Note>
A module can match multiple interface entries - if an import matches _any_ of the entries, it will be considered valid.
</Note>

## Layers

An ordered list of layers can be configured at the top level of `tach.toml`,
and [modules](#modules) can each be assigned to a specific layer.

```toml
layers = [
  "ui",
  "commands",
  "core"
]

[[modules]]
path = "tach.check"
layer = "commands"

[[modules]]
path = "tach.cache"
layer = "core"
```

The configuration above defines three layers, with `ui` being the highest layer, and `core` being the lowest layer.
It also tags `tach.check` as a module in the `commands` layer, and `tach.cache` in `core`.

[More details here.](../usage/layers)


## The Root Module

By default, Tach checks all of the source files beneath all of the configured [source roots](#source_roots), and will ignore dependencies which are not contained by [modules](#modules).

However, Tach allows configuration of how to treat code which is within a source root, but not contained by a module.

For example, given the file tree below:

```
my_repo/
  tach.toml
  script.py
  lib/
    module1.py
    module2/
      __init__.py
      service.py
    module3.py
  docs/
  tests/
```

If `lib.module1`, `lib.module2`, and `lib.module3` are the only configured modules, then the code in `script.py` would be automatically part of the `<root>` module.

This module can declare its own dependencies with `depends_on` and use the rest of the available module configuration.
Further, other modules would need to declare an explicit dependency on `<root>` to use code which rolls up to the root.

Tach allows configuring how the root module should be treated through the `root_module` key in `tach.toml`. It may take one of the following values:

- **(permissive default)** `"ignore"`: Disable all checks related to the `<root>` module. `tach check` will never fail due to code in the `<root>` module, and `tach sync` will never add `<root>` to `tach.toml`
- **(stricter)** `"allow"`: Treat `<root>` as a catch-all rollup module which must be explicitly declared as a dependency and must declare its own dependencies on other modules.
- **(stricter)** `"dependenciesonly"`: Forbid any module from listing `<root>` as a dependency, but allow `<root>` to declare its own dependencies.
- **(strictest)** `"forbid"`: Forbid any reference to the `<root>` module in tach.toml. This means that all code in [source roots](#source_roots) MUST be contained within an explicitly configured [module](#modules).

## Source Roots

The `source_roots` key is required for Tach to understand the imports within your project.
If it is not set explicitly, `source_roots` defaults to your project root path: `['.']`.
This means Tach will expect that your Python imports are resolved relative to the directory in which `tach.toml` exists.

Below are typical cases in which modifying `source_roots` is necessary.

### Example: Python below project root

Suppose your repository contains a subfolder where all of your Python code lives. This could be a web server, a collection of serverless functions, or even utility scripts.
In this example we will assume the Python code in our repo lives in the `backend/` folder.

```
my_repo/
  tach.toml
  backend/
    module1.py
    module2/
      __init__.py
      service.py
    module3.py
  docs/
  tests/
```

In a Python module such as `backend/module1.py`, we can see imports from other modules.

```python
# In backend/module1.py

import module3
from module2.service import MyService
```

Notice that these import paths (`module3`, `module2.service.MyService`) are rooted in the `backend/` folder, NOT the project root.

To indicate this structure to Tach, set:

```toml
source_roots = ["backend"]
```

in your `tach.toml`, or use [`tach mod`](../usage/commands#tach-mod) and mark the `backend` folder as the only source root.

### Example: Monorepo - Namespace Packages

Suppose you work on a 'monorepo', in which Python packages which import from each other are located in distinct project directories.
You may package your utility libraries in a `utility`folder, while your core packages live in `core_one` and `core_two`.
You may also use a [namespace package](https://peps.python.org/pep-0420/) to share a common top-level namespace. In this example we'll use `myorg` as the namespace package.

The file tree in a case like this might look like:

```
my_repo/
  tach.toml
  utility/
    pyproject.toml
    src/
      myorg/
        utils/
          __init__.py
  core_one/
    pyproject.toml
    src/
      myorg/
        core_one/
          __init__.py
          module1.py
          module2/
            __init__.py
            service.py
          module3.py
  core_two/
    pyproject.toml
    src/
      myorg/
        core_two/
          __init__.py
          module1.py
          module2/
            __init__.py
            service.py
          module3.py
  docs/
  tests/
```

In a Python module such as `core_one/src/myorg/core_one/module1.py`, there may be imports from other packages:

```python
# In core_one/src/myorg/core_one/module1.py

from myorg.utils import utility_fn
```

Notice that this import path (`myorg.utils.utility_fn`) is rooted in the `utility/src` folder, NOT the project root.

To indicate the project structure to Tach, you would set:

```toml
source_roots = [
  "utility/src",
  "core_one/src",
  "core_two/src"
]
```

in your `tach.toml`, or use [`tach mod`](../usage/commands#tach-mod) and mark the same folders as source roots.

<Note>
In `tach.toml`, each entry in `source_roots` is interpreted as a relative path from the project root.
</Note>

After configuring your source roots as above, you can use `tach check-external`
to validate that any dependencies between the packages are declared explicitly in the corresponding `pyproject.toml`.

For example, given the import shown above (`core_one` importing from `utility`),

```python
# In core_one/src/myorg/core_one/module1.py

from myorg.utils import utility_fn
```

Tach would validate that this is declared in `core_one/pyproject.toml`:

```toml
# In core_one/pyproject.toml
[project]
dependencies = ["myorg-utility"]
```

Note that this also assumes the `name` of the `utility` package has been set to `myorg-utility`:

```toml
# In utility/pyproject.toml
[project]
name = "myorg-utility"
```


### Example: Monorepo - Workspace Packages

Suppose you work on a 'monorepo', in which Python packages which import from each other are located in distinct project directories.
You may package your utility libraries in a `utility`folder, while your core packages live in `core_one` and `core_two`.
You may also use something like [uv workspaces](https://docs.astral.sh/uv/concepts/projects/workspaces/#getting-started) to organize these packages.

The file tree in a case like this might look like:

```
my_repo/
  tach.toml
  utility/
    pyproject.toml
    src/
      utility/
        __init__.py
  core_one/
    pyproject.toml
    src/
      core_one/
        __init__.py
        module1.py
        module2/
          __init__.py
          service.py
        module3.py
  core_two/
    pyproject.toml
    src/
      core_two/
        __init__.py
        module1.py
        module2/
          __init__.py
          service.py
        module3.py
  docs/
  tests/
```

In a Python module such as `core_one/src/core_one/module1.py`, there may be imports from other packages:

```python
# In core_one/src/core_one/module1.py

from utility import utility_fn
```

Notice that this import path (`utility.utility_fn`) is rooted in the `utility/src` folder, NOT the project root.

To indicate the project structure to Tach, you would set:

```toml
source_roots = [
  "utility/src",
  "core_one/src",
  "core_two/src"
]
```

in your `tach.toml`, or use [`tach mod`](../usage/commands#tach-mod) and mark the same folders as source roots.

<Note>
In `tach.toml`, each entry in `source_roots` is interpreted as a relative path from the project root.
</Note>

After configuring your source roots as above, you can use `tach check-external`
to validate that any dependencies between the packages are declared explicitly in the corresponding `pyproject.toml`.

For example, given the import shown above (`core_one` importing from `utility`),

```python
# In core_one/src/core_one/module1.py

from utility import utility_fn
```

Tach would validate that this is declared in `core_one/pyproject.toml`:

```toml
# In core_one/pyproject.toml
[project]
dependencies = ["myorg-utility"]
```

Note that this also assumes the `name` of the `utility` package has been set to `myorg-utility`:

```toml
# In utility/pyproject.toml
[project]
name = "myorg-utility"
```

## `tach.domain.toml`

Tach allows splitting your configuration into 'domains', or sub-folders of your project.
You can define modules and interfaces in a `tach.domain.toml` file which lives right next to the module code itself.

This enables multiple developers or teams to independently own and maintain their modules and interfaces.

### Modules

Within a `tach.domain.toml` file, you can define [modules](#modules) similar to modules in `tach.toml`.
The key difference is that paths are relative to the location of the domain by default, and there is a `[root]` module syntax for describing the parent folder itself.

For example, a `tach.toml` file containing the module definitions:
```toml
[[modules]]
path = "tach.filesystem"
depends_on = [
  "tach.hooks",
  "tach.filesystem.service",
]

[[modules]]
path = "tach.filesystem.service"
depends_on = []
```

could be expressed instead in a `tach.domain.toml` file at `<source root>/tach/filesystem/tach.domain.toml`:

```toml
[root]  # This defines "tach.filesystem"
depends_on = [
  "//tach.hooks",  # This refers to "tach.hooks" (outside of this domain)
  "service",  # This refers to "tach.filesystem.service"
]

[[modules]]
path = "service"  # This defines "tach.filesystem.service"
depends_on = []
```

Note that the `tach.domain.toml` file uses its location relative to the nearest source root to implicitly determine its `[root]` module path (`"tach.filesystem"`).

The domain configuration also uses special syntax to refer to dependencies on module paths outside of the domain, prefixing the absolute path with `"//"`.

Module paths are generally interpreted relative to the location of the `tach.domain.toml` file, which can be seen in the definition for the `"service"` module.
This path is interpreted relative to the domain root, meaning it refers to the `"tach.filesystem.service"` module.

### Interfaces

Interfaces are defined in largely the same way as in [`tach.toml`](#interfaces), with the key difference being the treatment of paths in the `from` field.
These will be interpreted as paths relative to the domain root.

For example, a `tach.toml` file containing the interface definitions:
```toml
[[interfaces]]
expose = ["service.*"]
from = ["tach.filesystem"]

[[interfaces]]
expose = ["client.*"]
from = ["tach.filesystem.git_ops"]
```

could be expressed instead in a `tach.domain.toml` file at `<source root>/tach/filesystem/tach.domain.toml`:

```toml
[[interfaces]]
expose = ["service.*"]
from = ["<domain_root>"]  # This matches "tach.filesystem"

[[interfaces]]
expose = ["client.*"]
from = ["git_ops"]  # This matches "tach.filesystem.git_ops"
```

### Example: `CODEOWNERS`

Tach domain configuration files enable smooth integration with [`CODEOWNERS`](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners):

```CODEOWNERS
# Domain ownership for different teams

/tach.toml    @platform-team

/payments/tach.domain.toml    @payments-team
/auth/tach.domain.toml    @auth-team
/data/analytics/tach.domain.toml    @analytics-team @data-team
/mobile/tach.domain.toml    @mobile-team
/libs/shared/tach.domain.toml    @platform-team
```

This allows a team to own their public interface, without imposing a bottleneck on other teams' configuration changes.

## External

When running [`check-external`](commands#tach-check-external), Tach allows excluding certain modules from validation.

Adding the top level module name to the `exclude` key (underneath the `external` key) will allow all usages of the corresponding module.

Example:
```toml
[external]
exclude = ["PIL"]
```

Tach also allows supplying a `rename` field to handle cases where the top level module name does not match the name of the package.

For example, the `pillow` package supplies the `PIL` module, so Tach needs to map imports from `PIL` to the `pillow` package specifier in your requirements.

```toml
[external]
rename = [
  # Format "[module name]:[package name]"
  "PIL:pillow",
  ...
]
```

In most cases you should not need to specify `rename` manually (see the Note below).

<Note>
  It is recommended to run Tach within a virtual environment containing all of
  your dependencies across all packages. This is because Tach uses the
  distribution metadata to map module names like 'git' to their distributions
  ('GitPython').
</Note>

## Rules

Tach allows configuring the severity of certain issues. Each entry in the `rules` table can be set to `error`, `warn`, or `off`.

The available rules and their defaults are listed below.

- `unused_ignore_directives` (**default**: `warn`): catch `tach-ignore` comments which are unused (e.g. do not suppress any errors or warnings)
- `require_ignore_directive_reasons` (**default**: `off`): require every `tach-ignore` comment to have a reason
- `unused_external_dependencies` (**default**: `error`): catch declared 3rd party dependencies which are not imported in your code


## Cache

Tach allows configuration of the [computation cache](caching) it uses to speed up tasks like [testing](commands#tach-test).

The `file_dependencies` key accepts a list of glob patterns to indicate additional file contents that should be considered when [checking for cache hits](caching#determining-cache-hits). This should typically include files outside of your [source roots](#source-roots) which affect your project's behavior under test, including the tests themselves. Additionally, if you have non-Python files which affect your project's behavior (such as Rust or C extensions), these should be included as well.

The `env_dependencies` key accepts a list of environment variable names whose values affect your project's behavior under test. This may include a `DEBUG` flag, or database connection parameters in the case of tests which use a configurable database.

</document_content>
</document>
<document index="9">
<source>docs/usage/deprecate.mdx</source>
<document_content>
---
title: Deprecate Dependencies
---

A dependency can be marked as `deprecated` - this means that the intention is to remove it over time, but it is still allowed.
`tach check` will not error on deprecated dependencies, but it will surface each import that uses the deprecated dependency.

## Example

Given modules called 'core' and 'parsing':

```toml
[[modules]]
path = "parsing"
depends_on = [
    { path = "core", deprecated = true }
]

[[modules]]
path = "core"
depends_on = []
```

Then, in `parsing.py`:

```python
from core.main import get_data # we want to remove this!

get_data()
```

This import won't fail `tach check`, instead you'll see:
```shell
‼️ parsing.py[L1]: Import 'core.get_data' is deprecated. 'parsing' should not depend on 'core'.
✅ All modules validated!
```

Note that we still see that all module dependencies are valid! To fail on the dependency, simply remove it from the `depends_on` key.


</document_content>
</document>
<document index="10">
<source>docs/usage/faq.mdx</source>
<document_content>
---
title: FAQ
---

### How does it work?

Tach works by analyzing the imports in your Python modules.
When you define dependencies in your project-level `tach.toml`, running `tach check` will verify that the imports in your modules match your expected dependencies.

### What is a module?

A 'module' is a Python module with dependencies configured in `tach.toml`. A module can be a python file or a directory.
The module is identified by its import path from the nearest source root (e.g. `a.b` for `<root>/a/b.py`),
and its dependencies can be listed in the `depends_on` key containing module paths in the same format.

[See more information on configuration here.](./configuration)

### Can I declare a module without restricting its dependencies?

Yes, you can remove the `depends_on` key from the module in your `tach.toml` configuration. Tach will then be aware of the module boundary so that it can be referenced in other modules' dependencies,
even if you don't want to restrict the dependencies of the module itself.

```toml
[[modules]]
path = "my.module"
# no 'depends_on' key here means this module can depend on anything
```

### How can I isolate a module from the rest of the code?

To prevent any external usage of a given module, you can set `visibility: []` for the module in `tach.toml`. This means that no other module can declare an explicit dependency on this module.

[See more information on configuration here.](./configuration)

### How can I declare modules which are freely usable by the rest of the code?

This is typically done for modules like `utils/`, `errors/` or `lib/`, which contain relatively isolated code which can be used throughout a project.

Tach allows marking these modules as **Utilities**, which means they can be used without being listed as an explicit dependency.

<Note>
  Marking a module with `utility: true` is different from `visibility: ['*']`.

  Even when a module has public visibility, other modules must declare an
  explicit dependency to use it (in fact, modules are publicly visible by
  default).

  In contrast, a utility module does not require its dependents to
  list an explicit dependency.
</Note>

[See more information on configuration here.](./configuration)

### How can I define a public interface for a module?

[Public interfaces](./interfaces) are defined in [tach.toml](./configuration#interfaces), and restrict the imports which are allowed from a given module.
This is useful when you want to expose a stable API from a module and prevent other modules from becoming deeply coupled to its implementation details.

[See more information on configuration here.](./configuration)

### Are conditional imports checked?

Tach will check all imports in your source files, including those which are called conditionally.
The only exceptions are imports made within `TYPE_CHECKING` conditional blocks.
By default, Tach will **not** report errors from `TYPE_CHECKING` blocks. If you want to enable checks for
these imports, you can add `ignore_type_checking_imports: false` to your `tach.toml`.

[See more information on configuration here.](./configuration)

### Can you catch dynamic references?

Since Tach uses the AST to find imports and public members, dynamic imports (e.g. using a string path) and dynamic names (e.g. using `setattr`, `locals`, `globals`) are not supported. If these usages cause Tach to report incorrect errors, the [ignore directive](tach-ignore) should be sufficient to reach a passing state.

### How can I make a feature request or file a bug?

This project uses [GitHub Issues](https://github.com/gauge-sh/tach/issues) to track bugs and feature requests. Search the existing
issues before filing new issues to avoid duplicates. File your bug or
feature request as a new Issue.

### How can I get help?

For help and questions, join the [Discord](https://discord.gg/a58vW8dnmw)!

### How can I report a security issue?

Do not report security vulnerabilities through public GitHub issues. Instead, please send a DM to caelean or nashsando on [Discord](https://discord.gg/a58vW8dnmw). You can also email us at caelean@gauge.sh or evan@gauge.sh. If the issue is significant, we will consider paying a bounty.

### What information does Tach track?

Tach tracks anonymized usage and error report statistics; we ascribe to Posthog's approach as detailed [here](https://posthog.com/blog/open-source-telemetry-ethical).
If you would like to opt out of sending anonymized info, you can set `disable_logging` to `true` in your `tach.toml`.

</document_content>
</document>
<document index="11">
<source>docs/usage/interfaces.mdx</source>
<document_content>
---
title: Interfaces
---

A module can adopt a public interface by matching interface rules in [`tach.toml`](./configuration#interfaces).

## How does it work?

When Tach is checking imports from a module with a [public interface](./configuration#interfaces), it will verify that the import matches one of the `expose` patterns.
This prevents other modules from becoming coupled to implementation details, and makes future changes easier.

### Example

Given modules called 'core' and 'domain', we may have `tach.toml` contents like this:

```toml
[[modules]]
path = "domain"
depends_on = [
    "core"
]

[[modules]]
path = "core"
depends_on = []

[[interfaces]]
expose = ["get_data"]
from = ["core"]
```

Then, in `domain.py`, we may have:

```python
from core.main import DataModel  # This import fails

DataModel.objects.all()
```

This import would **fail** `tach check` with the following error:

```shell
❌ domain.py[L1]: Module 'core' has a public interface. Only imports from the public interface of this module are allowed. The import 'core.main.DataModel' (in module 'parsing') is not public.
```

In this case, there is a public interface defined in `tach.toml` which includes a service method to use instead.

```python
from core import get_data  # This import is OK

get_data()
```

`tach check` will now pass!

```bash
✅ All modules validated!
```


## Interface visibility

Interfaces can specify `visibility`, similar to [modules](../usage/configuration#modules).

This allows 'splitting' the interface, usually to support a detailed/sensitive interface for some consumers while maintaining a minimal interface by default.

### Example

```toml
[[modules]]
path = "api"
depends_on = []

[[interfaces]]
expose = ["read_data"]
from = ["api"]

[[interfaces]]
expose = ["write_data"]
from = ["api"]
visibility = ["admin.controller"]  # limiting visibility of this interface
```

In the configuration shown above, the `api` module exposes only `read_data` to most consumers,
while also providing `write_data` through an interface visible only to `admin.controller`.

You may attach an arbitrary number of interfaces to the same module, with varying `visibility`.


### Example: Exclusive interface

It is also possible to mark an interface with `exclusive: true`.

When an interface is `exclusive`, it will override all other matching interfaces for the module,
which is only relevant when using `visibility` as shown above.

Using the example above:

```toml
[[modules]]
path = "api"
depends_on = []

[[interfaces]]
expose = ["read_data"]
from = ["api"]

[[interfaces]]
expose = ["write_data"]
from = ["api"]
visibility = ["admin.controller"]
exclusive = true  # marking this interface as 'exclusive'
```

By marking the `write_data` interface as exclusive, we are saying that `admin.controller` should _exclusively_ use `api` through that interface (e.g. `write_data`).

</document_content>
</document>
<document index="12">
<source>docs/usage/layers.mdx</source>
<document_content>
---
title: Layers
---

An ordered list of layers can be configured at the top level of [`tach.toml`](../usage/configuration#layers),
and [modules](../usage/configuration#modules) can each be assigned to a specific layer.

## How does it work?

[Layered architecture](https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch01.html) is often
an effective starting point for modularizing an application.

The idea is straightforward:
**Higher layers may import from lower layers, but lower layers may NOT import from higher layers.**

Defining this architecture is more concise and flexible than specifying all module dependencies
with `depends_on`, which makes it easier to adopt in an existing project.

Tach allows defining and enforcing a layered architecture with any number of vertically-stacked layers.

When a module is assigned to a layer, this module:
- may freely depend on modules in **lower layers**, *without declaring these dependencies*
- must explicitly declare dependencies in **its own layer**
- may never depend on modules in **higher layers**, *even if they are declared*

## Example

We can use the Tach codebase itself as an example of a 3-tier layered architecture:

```toml
layers = [
  "ui",
  "commands",
  "core"
]

[[modules]]
path = "tach.check"
layer = "commands"

[[modules]]
path = "tach.cache"
depends_on = ["tach.filesystem"]
layer = "core"

[[modules]]
path = "tach.filesystem"
depends_on = []
layer = "core"
```

In the configuration above, three layers are defined.
They are similar to the classic `Presentation` - `Business Logic` - `Data` which are often found in web applications,
but a bit different given that Tach is a CLI program.

In Tach, the highest layer is `UI`, which includes code related to the CLI and other entrypoints to start the program.

Just below this, the `Commands` layer contains high-level business logic which implements each of the CLI commands.

At the bottom is the `Core` layer, which contains utilities, libraries, and broadly relevant data structures.

Given this configuration, `tach.check` does not need to declare a dependency on `tach.cache` or `tach.filesystem` to use it,
because the `Commands` layer is higher than the `Core` layer.

However, `tach.cache` needs to explicitly declare its dependency on `tach.filesystem`, because they
are *both* in the `Core` layer.

</document_content>
</document>
<document index="13">
<source>docs/usage/tach-ignore.mdx</source>
<document_content>
---
title: tach-ignore
---

To ignore a particular import which should be allowed unconditionally, use the `tach-ignore` comment directive.

```python
# tach-ignore
from core.main import private_function

from core.api import private_calculation  # tach-ignore

from core.package import (  # tach-ignore
    service_one,
    service_two
)
```

The directive can also be specific about the import to ignore, which is particularly useful when importing multiple packages.

```python
# tach-ignore private_function
from core.main import private_function, public_function

from core.api import private_calculation, public_service  # tach-ignore private_calculation

from core.package import (  # tach-ignore service_two
    service_one,
    service_two
)
```

Note: Names given to `tach-ignore` should match the alias as it is used in the subsequent import line, not the full module path from the project root.

## Reasons

Tach also allows you to add a message next to the ignore directive, to document the reasoning for the ignore.

```python
# tach-ignore(Alternative API not yet available 11/26/24) private_api
from core.api import private_api
```

</document_content>
</document>
<document index="14">
<source>docs/usage/unchecked-modules.mdx</source>
<document_content>
---
title: Unchecked Modules
---

---

A module can be marked 'unchecked' by setting `unchecked: true` in its configuration within [`tach.toml`](configuration#tachtoml).

## How does it work?

An **unchecked** module should be thought of as a 'known' module which does not have any restriction on its dependencies.

The purpose of configuring an unchecked module is to better support **incremental adoption** of Tach.

<Note>
Setting `unchecked: true` is different from omitting the `depends_on` field.

An unchecked module is allowed to import anything, from any module - even when the module declares a [public interface](configuration#interfaces).

In contrast, a module with `depends_on` omitted will still need to respect public interfaces.
</Note>

## Example

Suppose you are adding Tach to an existing project, and you want to start by restricting dependencies for only one part of the codebase.

```
my_repo/
  tach.toml
  utils.py
  filesytem/
    service.py
  parsing/
    service.py
  core/
    module1.py
    module2/
      __init__.py
      service.py
    module3.py
  docs/
  tests/
```

Given the example project above, one might mark `utils`, `filesystem`, `parsing`, and `core.module(1,2,3)` as modules.

After doing this, `tach sync` would detect and add all the dependencies found between these modules, and `tach check` would enforce them.

However, suppose that `parsing`, `core.module2`, and `core.module3` are changing rapidly, and errors from `tach check` due to changing dependencies are unnecessary.
By default, Tach would require the configuration to be 'all-or-nothing' - these errors would be unavoidable if these modules are themselves dependencies of more stable modules.

```toml
[[modules]]
path = "utils"
utility = true
depends_on = []

[[modules]]
path = "filesystem"
depends_on = []

[[modules]]
# this module is not checked because its errors would be noisy
path = "parsing"
unchecked = true
depends_on = []

[[modules]]
# Tach will verify this module's dependencies,
# even though they are unchecked
path = "core.module1"
depends_on = ["core.module2", "core.module3", "parsing"]

[[modules]]
# this module is not checked because its errors would be noisy
path = "core.module2"
unchecked = true
depends_on = []

[[modules]]
# this module is not checked because its errors would be noisy
path = "core.module3"
unchecked = true
depends_on = []
```

Using `unchecked: true` in the configuration above allows restricting dependencies for `core.module1` at a fine-grained level without needing to restrict dependencies for all other modules.

</document_content>
</document>
<document index="15">
<source>docs/usage/vscode.mdx</source>
<document_content>
---
title: VSCode
---

Tach is installable as a VS Code extension which can be found [here](https://marketplace.visualstudio.com/items?itemName=Gauge.tach).
Instructions for installation and setup are in the extension README and on the [marketplace link](https://marketplace.visualstudio.com/items?itemName=Gauge.tach).

If you have any questions or run into any issues, let us know by either reaching out on [Discord](https://discord.gg/a58vW8dnmw) or submitting a [Github Issue](https://github.com/gauge-sh/tach/issues)!

</document_content>
</document>